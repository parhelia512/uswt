package org.eclipse.swt.tools.internal;

import java.io.PrintStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public abstract class CNIGenerator {

  private static int compare(Class a, Class b) {
    return a.getName().compareTo(b.getName());
  }

  private static void sort(Class[] classes) {
    Arrays.sort(classes, new Comparator() {
        public int compare(Object a, Object b) {
          return compare((Class) a, (Class) b);
        }
      });
  }

  private static String name(Class c) {
    String name = c.getName();
    return name.substring(name.lastIndexOf('.') + 1, name.length());
  }

  private static void generateStructureFunctions(PrintStream out,
                                                 Class[] classes)
  {
    sort(classes);

    for (int i = 0; i < classes.length; ++i) {
      generateReader(out, classes[i]);
      generateWriter(out, classes[i]);
    }

    out.println();    
  }

  private static boolean ignoreField(Field field) {
    int m = field.getModifiers();
    return
      ((m & Modifier.PUBLIC) == 0) ||
      ((m & Modifier.FINAL) != 0) ||
      ((m & Modifier.STATIC) != 0);
  }

  private static void generateReader(PrintStream out, Class c) {
    String name = name(c);

    out.print("void get");
    out.print(name);
    out.print("Fields(");
    generateType(out, c);
    out.print("* src, ");
    out.print(name);
    out.println("* dst)");
    
    out.println("{");

    Field[] fields = c.getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      if (ignoreField(fields[i])) continue;

      FieldData data = metaData.getMetaData(fields[i]);

      String exclude = data.getExclude();
      if (exclude.length() > 0) out.println(exclude);

      Class type = field.getType();
      String accessor = data.getAccessor();

      if (accessor == null || accessor.length() == 0)
        accessor = field.getName();

      if (type.isPrimitive()) {
        out.print("  dst->");
        out.print(accessor);
        out.print(" = src->");
        out.print(field.getName());
        out.println(";");
      } else if (type.isArray()) {
        Class componentType = type.getComponentType();
        if (componentType.isPrimitive()) {
          out.print("  for (unsigned i = 0; i < src->");
          out.print(field.getName());
          out.println("->length; ++i) {");
        
          out.print("    dst->");
          out.print(accessor);
          out.print("[i] = src->");
          out.print(field.getName());
          out.println("[i];");

          out.println("}");
        } else {
          throw new RuntimeException("not yet implemented");
        }
      } else {
        String typeName = className(type);

        out.print("  if (src->");
        out.print(field.getName());
        out.print(") get");
        out.print(typeName);
        out.print("Fields(src->");
        out.print(field.getName());
        out.print(", &(dst->");
        out.print(accessor);
        out.println("));");
      }

      if (exclude.length() != 0) outputln("#endif");
    }

    out.println("}");
  }
  
  private static void generateWriter(PrintStream out, Class c) {
    String name = name(c);

    out.print("void set");
    out.print(name);
    out.print("Fields(");
    generateType(out, c);
    out.print("* dst, ");
    out.print(name);
    out.println("* src)");
    
    out.println("{");

    Field[] fields = c.getDeclaredFields();
    for (int i = 0; i < fields.length; i++) {
      if (ignoreField(fields[i])) continue;

      FieldData data = metaData.getMetaData(fields[i]);

      String exclude = data.getExclude();
      if (exclude.length() > 0) out.println(exclude);

      Class type = field.getType();
      String accessor = data.getAccessor();

      if (accessor == null || accessor.length() == 0)
        accessor = field.getName();

      if (type.isPrimitive()) {
        out.print("  dst->");
        out.print(field.getName());
        out.print(" = src->");
        out.print(accessor);
        out.println(";");
      } else if (type.isArray()) {
        Class componentType = type.getComponentType();
        if (componentType.isPrimitive()) {
          out.print("  for (unsigned i = 0; i < src->");
          out.print(field.getName());
          out.println("->length; ++i) {");
        
          out.print("    dst->");
          out.print(field.getName());
          out.print("[i] = src->");
          out.print(accessor);
          out.println("[i];");

          out.println("}");
        } else {
          throw new RuntimeException("not yet implemented");
        }
      } else {
        String typeName = className(type);

        out.print("  if (dst->");
        out.print(field.getName());
        out.print(") set");
        out.print(typeName);
        out.print("Fields(&(dst->");
        out.print(field.getName());
        out.print("), src->");
        out.print(accessor);
        out.println(");");
      }

      if (exclude.length() != 0) outputln("#endif");
    }

    out.println("}");
  }
  
  private static void generateNatives(PrintStream out, Class[] classes) {
    sort(classes);

    for (int i = 0; i < classes.length; ++i) {
      generateInclude(out, classes[i]);
    }

    out.println();

    for (int i = 0; i < classes.length; ++i) {
      generateMethods(out, classes[i]);
    }
  }

  private static void generateInclude(PrintStream out, Class c) {
    out.print("#include \"");
    for (StringTokenizer st = new StringTokenizer(c.getName(), ".");
         st.hasMoreTokens();)
    {
      out.print(st.nextToken());
      if (st.hasMoreTokens()) out.print("/");
    }
    out.println(".h\"");
  }

  private static int compareParameters(Method a, Method b) {
    Class[] pa = a.getParameterTypes();
    Class[] pb = b.getParameterTypes();
    if (pa.length == pb.length) {
      for (int i = 0; i < pa.length; ++i) {
        int r = compare(pa[i], pb[i]);
        if (r != 0) return r;
      }
      return 0;
    } else {
      return pa.length - pb.length;
    }
  }

  private static void sort(Method[] methods) {
    Arrays.sort(methods, new Comparator() {
        public int compare(Object a, Object b) {
          Method ma = (Method) a;
          Method mb = (Method) b;
          int r = ma.getName().compareTo(mb.getName());
          return (r == 0 ? compareParameters(ma, mb) : r);
        }
      });
  }
  
  private static void generateMethods(PrintStream out, Class c) {
    Method[] methods = c.getDeclaredMethods();
    sort(methods);

    for (int i = 0; i < methods.length; ++i) {
      if ((methods[i].getModifiers() & Modifier.NATIVE) != 0) {
        generateMethod(out, methods[i]);
        out.println();
      }
    }
  }

  private static void generateTypeName(PrintStream out, Class c) {
    for (StringTokenizer st = new StringTokenizer(c.getName(), ".");
         st.hasMoreTokens();)
    {
      out.print(st.nextToken());
      if (st.hasMoreTokens()) out.print("::");
    }
  }

  private static void generateType(PrintStream out, Class c) {
    if (c == Void.TYPE) out.print("void");
    else if (c == Integer.TYPE) out.print("jint");
    else if (c == Boolean.TYPE) out.print("jboolean");
    else if (c == Long.TYPE) out.print("jlong");
    else if (c == Short.TYPE) out.print("jshort");
    else if (c == Character.TYPE) out.print("jchar");
    else if (c == Byte.TYPE) out.print("jbyte");
    else if (c == Float.TYPE) out.print("jfloat");
    else if (c == Double.TYPE) out.print("jdouble");
    else if (c.isArray()) {
      out.print("JArray< ");
      generateType(out, c.getComponentType());
      out.print(" >*");
    } else {
      generateTypeName(out, c);
      out.print("*");
    }
  }

  private static void generateLocals(PrintStream out, Method m) {
    Class[] types = m.getParameterTypes();
    for (int i = 0; i < types.length; ++i) {
      if (types[i].isPrimitive() || isSystemClass(types[i])) continue;
      ParameterData data = metaData.getMetaData(m, i);
      out.print("  ");
      if (types[i] == String.class) {
        if (paramData.getFlag("unicode")) {
          out.print("const jchar* ap");
          out.print(i);
          out.print(" = 0;");
        } else {
          out.print("int al");
          out.print(i);
          out.print(" = JvGetStringUTFLength(a");
          out.print(i);
          out.println(");");

          out.print("const char ap");
          out.print(i);
          out.print("[al");
          out.print(i);
          out.print(") + 1];");
        }
      } else if (! types[i].isArray()) {
        out.print(className(types[i]));
        out.print(" as" + i);
        if (data.getFlag("init")) out.print(" = { 0 }");
        out.print(", *ap" + i);
        out.println(" = 0;");
      }
    }
  }

  private static void generateRead(PrintStream out, Method m, Class type,
                                   ParameterData data, int i)
  {
    if (type.isPrimitive() || isSystemClass(type) || type.isArray()) return;

    if (type == String.class) {
      if (data.getFlag("unicode")) {
        out.print("ap");
        out.print(i);
        out.print(" = JvGetStringChars(a");
        out.print(i);
        out.println(");");
      } else {
        out.print("JvGetStringChars(a");
        out.print(i);
        out.print(", 0, al");
        out.print(i);
        out.print(", ap");
        out.print(i);
        out.println(");");
      }
    } else {
      if (! data.getFlag("no_in")) {
        output("get");
        output(className(type));
        output("Fields(a");
        output(i);
        output(", &as");
        output(i);
        output(")");
      }
    }
  }

  private static void generateReads(PrintStream out, Method m) {
    Class[] types = m.getParameterTypes();
    for (int i = 0; i < types.length; ++i) {
      generateRead(out, m, types, metaData.getMetaData(m, i), i);
    }
  }

  private static void generateWrite(PrintStream out, Method m, Class type,
                                    ParameterData data, int i)
  {
    if (type.isPrimitive() || isSystemClass(type) || type == String.class
        || type.isArray()) return;

    if (! data.getFlag("no_out")) {
      output("set");
      output(className(type));
      output("Fields(a");
      output(i);
      output(", &as");
      output(i);
      output(")");
    }
  }

  private static void generateWrites(PrintStream out, Method m) {
    Class[] types = m.getParameterTypes();
    for (int i = types.length; i >= 0; --i) {
      generateWrite(out, m, types, metaData.getMetaData(m, i), i);
    }
  }

  private static void generateCall(PrintStream out, Method m, MethodData data)
  {
    out.println("  {");

    

    out.println("  }");
  }
  
  private static void generateMethod(PrintStream out, Method m) {
    generateType(out, m.getReturnType());
    out.println();

    generateTypeName(out, m.getDeclaringClass());
    out.println("::");

    out.print(m.getName());
    out.println();

    out.print("  (");    
    Class[] parameters = m.getParameterTypes();
    for (int i = 0; i < parameters.length; ++i) {
      generateType(out, parameters[i]);
      out.print(" p");
      out.print(i);
      if (i < parameters.length - 1) out.print(", ");
    }
    out.println(")");
    
    out.println("{");

    MethodData data = metaData.getMetaData(m);
    String function = getFunctionName(m);

    generateLocals(out, m);
    generateReads(out, m);
    if (data.getFlag("dynamic")) {
      generateDynamicCall(out, m, data);
    } else {
      generateCall(out, m, data);
    }
    generateWrites(out, m);

    out.println("}");
  }

  public static void generateAll(PrintStream out) throws Exception {
    new MyGeneratorApp(out).generateAll();
  }

  public static void main(String[] args) throws Exception {
    if (args.length != 1) {
      System.err.println
        ("usage: java " + CNIGenerator.class.getName() + " <output_file>");
      System.exit(-1);
    }

    PrintStream out = new PrintStream(new BufferedOutputStream
                                      (new FileOutputStream(args[0])));
    try {
      generateAll(out);
    } finally {
      out.close();
    }
  }

  private static class MyGeneratorApp extends JNIGeneratorApp {
    private final PrintStream out;
    
    private MyGeneratorApp(PrintStream out) {
      this.out = out;
    }

    public void generate() {
      generateStructureFunctions(out, getStructureClasses());
      generateNatives(out, getNativesClasses());
    }
  }

}
